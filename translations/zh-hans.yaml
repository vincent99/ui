---
languageName: "简体中文"
languageContribute: "帮助翻译 Rancher"
generic:
  actions: 操作
  activate: 激活
  all: 全部
  any: 任何
  as: 以
  cancel: 取消
  closeModal: 关闭
  cluster: 集群
  collapseAll: 折叠全部
  command: 命令
  confirm: 确认
  containers: 容器
  created: 创建
  createdDate: "创建于{date}"
  default: 默认
  description: 描述
  details: 详情
  disable: 禁用
  disabled: 禁用
  dockerId: '容器 ID:'
  domainName: 域名
  enable: 启用
  enabled: 启用
  entrypoint: 入口
  environment: 环境
  expandAll: 全部展开
  hardware: 硬件
  healthy: 健康
  host: 主机
  id: ID
  image: 镜像
  internal: 内部
  ipAddress: IP地址
  limit: 限制
  limits: 限制
  loading: "加载中..."
  missing: "*%MISSING% *"
  moreActions: 更多操作
  na: '不适用'
  name: 名称
  no: "取消"
  noRating: 无评价
  none: 无
  ports: 端口
  remove: 移除
  role: 角色
  save: 保存
  saved: 已保存
  saving: 保存中
  search: 搜索
  seconds: 秒
  select: 选择
  service: 服务
  services: 服务
  state: 状态
  tags: 标签
  test: 测试
  testing: 测试
  to: 至
  total: 合计
  type: 类型
  unknown: 未知
  uuid: UUID
  yes: "确定"
realmNames:
  all: 全部
  usWest: 美国西部
  usEast: 美国东部
  asia: 亚洲
  euWest: 欧洲西部
  euEast: 欧洲东部
accountsPage:
  index:
    table:
      id: ID
      kind: 类型
      username: 用户名
      identity: 标识
      noName: 无
  new:
    form:
      username:
        placeholder: "例如:jsmith"
      password:
        labelText: 密码
      name:
        placeholder: "例如:John Smith"
      type:
        labelText: 账号类型
      description:
        labelText: 描述
        placeholder: "例如:这是John Smith的账号"
apiPage:
  header: 环境API Keys
  actionButton: 添加环境API Key
  content: |
    环境API Keys与当前环境(<code>{displayName}</code>)绑定，仅能用于管理当前环境的资源。当前环境中具有权限的其他账号也能够管理这些API Keys。
  currentEndpoint: '端点:'
  table:
    state: 状态
    name: 名称
    description: 描述
    publicValue: 访问密钥
    created: 已创建
    noData: 此环境还没有创建API Keys
    noName: 无
    noDescription: 无
    noPublicValue: 无public value
  account:
    header: 账号API Keys
    buttonText: 添加账号API Key
    content:
      paragraph1: 账号API Keys与你的用户账号绑定，
      paragraph2: "能够创建、删除及管理您有权限访问的所有环境。"
    table:
      noData: 您还没有创建任何账号API Keys。
auditLogsPage:
  header: 审计日志
  form:
    eventType:
      placeholder: 事件类型
    resourceType:
      placeholder: "资源类型:"
      dropdownPlaceholder: '选择一种资源类型:'
    resourceId:
      placeholder: 资源ID
    requestIp:
      placeholder: 请求IP
    authType:
      placeholder: "认证类型:"
      dropdownPlaceholder: '选择认证类型:'
    clearButtonText: 全部清除
    searchButtonText: 搜索
  table:
    time: 时间
    eventType: 事件类型
    description: 描述
    environment: 环境
    resourceTypeId: "资源类型:Id"
    identity: 认证用户
    authIp: "认证类型&IP"
authPage:
  shibboleth:
    enabled:
      header: "{providerName}已启用"
      required: |
        {appName} 已被设置为允许 {orgs, plural,
        =0 {无组织}
        =1 {# 个组织}
        other {# 个组织}
        } 和 {users, plural,
        =0 {无用户}
        =1 {# 个用户}
        other {# 个用户}
        } 访问.
      restricted: |
        {appName} 已被设置为允许 {orgs, plural,
        =0 {无组织}
        =1 {# 个组织}
        other {# 个组织}
        } and {users, plural,
        =0 {无用户}
        =1 {# 个用户}
        other {# 个用户}
        } 以环境成员身份访问.
      unrestricted: "{appName}已被设置为允许任何{providerName}用户访问."
      authenticated:
        header:
          text: 认证
      disableAccess:
        header: "Danger Zone&trade;"
        warning: '<b class="text-danger">警告:</b> 禁用访问控制将导致任何能够访问此页面或API的用户拥有对 {appName} 的完全控制权限。'
        confirmDisable: "确认? 再次点击将关闭访问控制。"
        disable: 关闭访问控制
      groupsField: '组︰'
      displayName: '显示名称：'
      userName: '用户名：'
      userId: '用户ID：'
    disabled:
      header: '1. 配置Shibboleth账号'
      label: "{providerName} 未配置"
      warning: "{appName}可以设置为允许一组{providerName}用户和组织成员访问。 由于当前未完成此设置，所以任何可以访问此页面(或API)的用户都对系统有完全控制权限。"
      name:
        labelText: 显示名称字段
      username:
        labelText: 用户名字段
      uid:
        labelText: UID 字段
      groups:
        labelText: 组织字段
      testAuth:
        header: '2. 测试并启用验证'
        subtext: '测试以确认你的配置是否正确:'
        buttonText:
          pre: 使用 IDP 验证
          post: 等待 IDP 响应
    providerName:
      shibboleth: Shibboleth
  root:
    header: Access Control
  github:
    standard: GitHub
    enterprise: GitHub企业版
    header:
      enabled:
        label: "{github} 已启用"
        required: |
          {appName} 已被设置为允许 {orgs, plural,
          =0 {无组织}
          =1 {# 个组织}
          other {# 个组织}
          } 和 {users, plural,
          =0 {无用户}
          =1 {# 个用户}
          other {# 个用户}
          } 访问.
        restricted: |
          {appName} 已被设置为允许 {orgs, plural,
          =0 {无组织}
          =1 {# 个组织}
          other {# 个组织}
          } and {users, plural,
          =0 {无用户}
          =1 {# 个用户}
          other {# 个用户}
          } 以环境成员身份访问.
        unrestricted: "{appName} 已被设置为允许任何 {github} 用户访问."
      disabled:
        label: GitHub 未设置
        warning: "{appName} 可以设置为允许一组 GitHub 用户和组织成员访问。 由于当前未完成此设置，所以任何可以访问此页面(或API)的用户都对系统有完全控制权限。"
    authenticated:
      header:
        text: 认证信息
        enterpriseHostName: "企业版主机:"
        clientId:
          text: "客户端ID:"
          helpText: "要修改设置的GitHub应用，请在下方禁用访问控制后重新设置。"
      disableAccess:
        header: "危险区域&trade;"
        warning: '<b class="text-danger">警告:</b> 禁用访问控制将导致任何能够访问此页面或API的用户拥有对  {appName}  的完全控制权限。'
        confirmDisable: "确认? 再次点击将关闭访问控制。"
        disable: 关闭访问控制
    notAuthenticated:
      header: "1. 设置GitHub应用"
      ul:
        li1:
          text: '标准GitHub， <a href="https://github.com/settings/developers" target="_blank">点击此处</a> 在弹出的新窗口中进行应用设置。'
          ul:
            li1: "企业版GitHub，请登录你的账号，点击Settings，然后点击Applications进行设置。"
        li2:
          text: '点击 "Register new application" 并填写表单内容:'
          ul:
            li1: '<b>Application name:</b> <span class="text-muted">任何您喜欢的应用名称, 例如 My {appName}</span>'
            li2: 主页 URL
            li3: '<b>Application description:</b> <span class="text-muted">任何你喜欢的描述，可选</span>'
            li4: 授权回调 URL
        li3:
          text: '点击 "Register Application" '
      form:
        header: '2. 设置 {appName} 使用你的GitHub应用验证'
        subtext: '将新创建GitHub应用的Client ID和Secret复制粘贴到下方的对应输入框中'
        clientId:
          labelText: 客户端ID
        clientSecret:
          labelText: 客户端秘钥
        ghEnterprise:
          labelText: 使用私有GitHub企业版部署
        isGHEnterprise:
          labelText: 使用安全连接
        enterpriseHost:
          labelText: 企业版主机
          placeholder: '例如:github.example.com'
    testAuth:
      header: '3. 测试并启用验证'
      subtext: '测试以确认你的配置是否正确'
      buttonText:
        pre: GitHub验证
        post: 等待GitHub返回
  azuread:
    header:
      enabled: 'Azure AD 验证已 <b>启用</b>'
      disabled: 'Azure 域验证未配置'
    subtext:
      enabled: '{appName} 已经被设置为允许 Azure AD 账户访问'
      disabled: '{appName} 能够被设置为仅允许 {appName} 数据库中定义的用户访问。 当前系统未进行设置， 因此任何访问此页面（或API）的用户都具有系统的完全控制权限。'
    enabled:
      header: '危险区域&trade;'
      warning: '<b class="text-danger">警告:</b> 禁用访问控制将导致任何能够访问此页面或API的用户拥有对  {appName}  的完全控制权限。'
      reallyDisable: '确认? 再次点击将关闭访问控制。'
      promptDisable: 关闭访问控制
    configure:
      header: '1. 设置 Azure AD 账户'
      tenantId:
        label: 租户ID
        placeholder: UUID 字符串
        help: 由 Azure AD portal 获取
      clientId:
        label: 客户端ID
        placeholder: UUID 字符串
      domain:
        label: 域名
        placeholder: '例如: youcompany.onmicrosoft.com'
      adminAccountUsername:
        label: 管理员账号用户名
        placeholder: '例如: rancher-admin'
        help: 可以读取其他用户信息的账号
      adminAccountPassword:
        label: 管理员账号密码
    test:
      header: '2. 测试并启用验证'
      help: '测试验证以确认配置是否正确:'
      username:
        label: 登录用户名
        placeholder: '例如: jsmith'
      password:
        label: 登录密码
      pre: 通过Azure验证
      post: 等待Azure返回
  localAuth:
    header:
      enabled: '本地验证 <b>已启用</b>'
      disabled: '<p>本地验证未设置</p>'
    subtext:
      enabled:
        text: '{appName} 已设置为允许本地数据库中的账号访问。'
        linkText: 管理账号
      disabled: '{appName} 能够被设置为仅允许 {appName} 本地数据库中定义的用户访问。 当前系统未进行设置， 因此任何访问此页面（或API）的用户都具有系统的完全控制权限。'
    accessEnabled:
      header: '危险区域&trade;'
      warning: '<b class="text-danger">警告:</b> 禁用访问控制将导致任何能够访问此页面或API的用户拥有对  {appName}  的完全控制权限。'
      buttonText:
        disable: '确认? 再次点击将关闭访问控制。'
        prompt: 关闭访问控制
    accessDisabled:
      header: '1. 设置管理员用户'
      helpText: '该账户将成为管理员并拥有对 {appName} 的完全控制权限'
      form:
        login:
          labelText: 登录用户名
          placeholder: '例如:jsmith'
        name:
          labelText: 全名
          placeholder: '例如:John Smith'
        password:
          labelText: 密码
        confirmPassword:
          labelText: 确认密码
    accessControl:
      header: '启用访问控制'
      helpText: '点击以开启访问控制并登陆'
      buttonText:
        pre: 启用本地验证
        post: '启用中...'
  0:
    header: 访问控制
balancerPage:
  noMatch: 没有符合当前搜索的负载均衡
  noData: 没有任务负载均衡
  table:
    target: 目标
catalogPage:
  index:
    header: 应用商店
    refreshBtn: 刷新
    manage: 管理
    search:
      label: 搜索
    filters:
      label: 应用过滤
    certified:
      rancher:
        rancher: Rancher 实验室
        partner: 官方
      pl:
        rancher: 核心
        partner: 官方
    noData:
      singular: 没有符合的应用模板
      plural: 当前目录下没有符合的应用模板
    action:
      launch: 查看详情
      notCompatible: 不兼容
      alreadyDeployed: 已部署
certificatesPage:
  detail:
    header: '证书: {name}'
  index:
    header: 证书
    linkTo: 添加证书
  new:
    header: 添加证书
    form:
      name:
        placeholder: 例如:mydomain.com
      description:
        placeholder: 例如:mydomain.com的EV证书
clustersPage:
  newCluster: 添加集群
  import: 外部导入
  alert: 找不到任何可用的环境。在其他操作之前，请创建或者激活一个环境。
  cluster:
    label: 集群名称
  environment:
    label: 环境名称
  projects:
    label: 环境
  memory:
    label: 内存
  storage:
    label: 存储
containerPage:
  header: '容器: {name}'
  portsTab:
    header: 端口
    detail: '容器监听端口到主机公用 IP 地址端口的映射关系。'
  linksTab:
    header: 链接
    detail: '这些属性显示了其他容器和当前容器之间的链接。'
    noData: 当前容器没有链接
  volumesTab:
    header: 数据卷
    detail: '这些属性显示了附加到您的容器的数据卷。'
    table:
      path: 挂载点
      shared: 共享
      writable: 可写
      noData: 该容器未使用数据卷
      noMatch: 没有符合当前搜索的数据卷
      noContainers: 无其他容器
containersPage:
  table:
    sparkPrefixCpu: 'CPU: '
    sparkPrefixMemory: '内存:'
    sparkPrefixNetwork: '网络:'
    sparkPrefixStorage: '存储:'
    noData: 没有可以显示的容器
    noMatch: 没有符合当前搜索的容器
  welcome:
    container: 立即开始
    containerLink: 创建一个容器
    orchestrator: 安装另一个编排引擎
    kubernetesLink: 安装 Kubernetes
containerSubpod:
  childContainers: 容器
  childSidekicks: 从
dnsPage:
  noMatch: 没有匹配当前搜索的记录
  noData: 没有可以显示的DNS记录
  table:
    target: 目标
editDns:
  title:
    new: 添加DNS记录
    edit: 编辑DNS记录
  name:
    placeholder: '例如: myapp'
  description:
    placeholder: '例如: Current version of MyApp'
  selector:
    label: 容器选择器
    placeholder: '例如: mylabel=somevalue'
  mode:
    label: "解析为"
    dnsservice: 一个或多个服务
    selectorservice: 满足选择器的一组容器
    externalip: 一个或多个外部 IP 地址
    externalhostname: 一个外部主机名
  targetIp:
    label: 目标IP地址
    add: 添加目标IP地址
  hostname:
    label: 目标主机名
    placeholder: '例如: foobar.com'
  errors:
    hostnameRequired: '必须填写"目标主机名"'
    serviceRequired: '必须填写一个或多个"目标"'
    selectorRequired: '"容器选择器"是需要'
editVolume:
  define:
    global: 设置卷
    stack: 设置卷模版
    container: 设置卷模版
    action: 设置
  add:
    global: 添加卷
    stack: 添加卷模板
    container: 添加卷模板
  edit:
    global: 编辑卷
    stack: 编辑卷模板
    container: 编辑卷模板
  name:
    placeholder: 例如 myvol
  scope:
    label: 作用域
    global: 整个环境的数据卷
    stack: 一个特定应用栈内的卷
    container: 每个容器的独立数据卷
  driver:
    label: 驱动
    local: 本地磁盘
    nfs: Rancher NFS
    ebs: Rancher EBS
    efs: Rancher EFS
    longhorn: Rancher Longhorn
    standard: 标准的
    custom:
      label: 自定义
      placeholder: 自定义驱动名称
  driverOpts:
    label: 驱动选项
    addAction: 添加选项
failWhalePage:
  header: 错误
  reloadButton: |
    <a href="#" onclick="window.location.href = window.location.href; return false;">重新加载</a> 以重试或
  logoutButton: 注销
haPage:
  header: 高可用性(HA)
  setup:
    prefix: "可以在不同主机上部署多个服务器容器，以便 {appName} 一直保持运行，即使其中一个主机失败。  "
    link: 请参阅文档
    suffix: " 有关安装和使用信息。"
  table:
    address: 主机地址
    port: 端口
    heartbeat: 上次在线
    clustered: 群集
helpPage:
  header: 常用链接及信息
  banner: '最新发布 {发布于}:'
  environment:
    header: 什么是环境？
    content: |
      <p>{appName} 支持将资源分组归属到多个环境中。每个环境具有自己独立的基础架构资源及服务，并由一个或多个用户、团队或组织所管理。</p>
      <p>例如，您可以创建独立的“开发”、“测试”及“生产”环境以确保环境之间的安全隔离，将“开发”环境的访问权限赋予全部人员，但限制“生产”环境的访问权限给一个小的团队。</p>
    manageLink: 管理环境
  host:
    header: 什么是主机？
    content: |
      在添加第一个服务或容器之前，必须至少添加一台支持Docker{minVersion} 或以上版本的Linux主机，该主机需要能够通过HTTP方式访问{appName} 服务器。{appName} 支持添加多种形式的Linux主机，
      包括由任何公有云、私有云或裸机方式提供的虚拟机或物理机。
    contentLink: 了解更多
  stacks:
    header: 什么是应用栈和服务？
    content:
      paragraph1: |
        简单而言，服务是一组由相同docker镜像创建的容器，Rancher服务扩展了Docker的“link”概念以利用{appName}的轻量级分布式DNS服务用于服务发现。服务可以单独添加或通过应用商店部署。
      paragraph2: 服务也能够利用其他{appName}内置服务，如负载均衡、健康监控、升级支持以及高可用。
      link: 了解更多
    addServiceLink: 管理服务
    addCatalogLink: 通过应用商店添加服务
    manageServiceLink: 管理服务
  issues:
    header:
      text: 问题及文档
      tagline: 发现问题？
      fileBug: 提交Bug
    content:
      paragraph1: |
        {appName}是一个开源的软件平台，实现了一个在生产环境中运行容器的专用基础设施。Docker容器，作为一个越来越受欢迎的应用程序工作负载，对于基础设施服务，包括网络、存储、负载均衡器、安全、服务发现及资源管理等各方面提出了新的需求。
      graphic1:
        text: 发现bug？
        link: 在GitHub上提出问题
      graphic2:
        text: 更多有用信息
        link: |
          <a href="{docsLink}" target="_blank">关于{appName} 使用请参考官方文档</a>
          <br/>或 <a href="{companyLink}/learn/" target="_blank">观看我们的快速上手教程</a>
      graphic3:
        text: 需要故障诊断协助？
        link: 参考我们的常见问题解答
  forums:
    header: 论坛信息
    tagline: 加入讨论
    buttonText: 进入论坛
    announcements:
      header: 公告
      buttonText: 查看更多公告信息
    general:
      header: 综合
      buttonText: 查看更多综合讨论
    rancherOs:
      header: RancherOS
      buttonText: 查看更多RancherOS讨论
    rancher:
      header: Rancher
      buttonText: 查看更多Rancher讨论
  commercial:
    header: 商业支持
    content: |
      Rancher Labs提供对{appName}的商业化的企业级支持服务，包括24x7技术支持团队、漏洞优先修复等。此外我们还提供实施、集成及顾问服务以满足不同组织部署及扩展{appName}的需求。关于上述服务的详细信息，请联系我们的销售团队<a href="mailto:sales@rancher.com">sales@rancher.com</a>。
hostsPage:
  cloudHostsPage:
    addPage:
      launch: 启动
      transferUnit: TB
      instance: '类型:'
      storage: '存储:'
      transfer: '流量限制:'
      zone: '区域:'
      env: '环境'
      size: '大小：'
      os: '操作系统：'
      driver: '驱动：'
      template: '模板名称：'
  addContainer: 添加容器
  new:
    header:
      customText: 添加自定义宿主
    manageLink: 管理docker-machine驱动
    custom: 添加自定义宿主
  hostPage:
    limits:
      cpu: 'CPU 限制：'
      memory: '内存限制：'
      storage: '卷本地限制：'
    infoMultiStats:
      ip: 'IP地址'
      cpu: 'CPU'
      memory: '内存'
      storage: '数据卷'
      provider:
        labelText: '提供者:'
        noHost: 自定义
      kernel: '内核'
      docker: 'Docker:'
      os: '操作系统'
      milliCpu:
        labelText: mCPU
    containersTab:
      header: 容器
      detail: 在此主机上运行的容器列表
    portsTab:
      header: 端口
      detail: '这些属性显示哪些端口已被映射到哪里。'
      table:
        header:
          ip: IP地址
          port: 端口
          service: 服务
          container: 容器
        body:
          noData: 主机当前未映射任何端口
    storageTab:
      header: 卷
      detail: '这些属性显示您的主机卷细节。'
      table:
        header:
          state: 状态
          hostPath: 主机路径
          mounts: 挂载
        body:
          noData: 主机未使用任何数据卷
k8sImport:
  header: 使用外部已安装好的Kubernetes
  instructions: '复制，粘贴，然后在已有的Kubernetes中运行下面的命令。{appName}就会使用这个已经安装好的Kubernetes作为一个集群。'
  generating: 正在生成命令行
loginPage:
  greeting: "你好！<br>欢迎使用 {appName}"
  githubMessage: "{appName} 使用GitHub管理账号和团队。点击以下按钮以登录，我们将仅使用基本的GitHub账号信息。"
  shibbolethMessage: "{appName}使用Shibboleth管理账号。点击以下按钮以登录到设置的Shibboleth IDP."
  shibbolethError:
    401: "未授权"
    500: "内部服务器错误"
    generic: "尝试登录时发生错误 ({errorCode})。请重试。"
  error:
    authFailed: 用户名或密码不正确。
machinePage:
  inactive: 未激活
  builtin: 内置
notFoundPage:
  header: "查看的页面不存在！"
  linkTo: 回到首页
registriesPage:
  index:
    linkTo: 添加镜像库
    table:
      header:
        state: 状态
        address: 地址
        username: 用户名
        created: 创建时间
  new:
    header: 添加镜像库
    form:
      custom:
        labelText: 地址
        placeholder: 例如:registry.example.com
        help: 仅添加主机名或IP地址, 不要包含协议 (https://)
      username:
        labelText: 用户名
        placeholder: 例如:username
      password:
        labelText: 密码
        placeholder: 例如:password
secretsPage:
  index:
    header: 秘密
    linkTo: 添加秘密
    noData: 当前未创建任何密文
    noMatch: 没有符合搜索条件的密文
servicePage:
  header: '{type}: {name}'
  globalScale: '每个主机 {scale}'
  multistat:
    fqdn: 'FQDN:'
    scale: '数量:'
    image: '镜像:'
  external:
    externalIp: |
      {count, plural,
      =1 {个外部IP:}
      other {个外部IP:}
      }
    externalHostname: '外部主机名:'
  selector:
    label: '选择器:'
  containersTab:
    title: '容器'
    detail: '组成该服务的容器列表。'
  linksTab:
    header: 链接
    detail: '这些属性显示当前服务中容器之间的链接。'
    noData: 当前服务没有链接
  certsTab:
    title: 证书
    detail: 'TLS请求所使用的证书'
    default: 默认证书
    additional: 其他SNI证书
  new:
    form:
      name:
        placeholder: 例如:myapp
      description:
        placeholder: 例如:我的应用
  newBalancer:
    upgradeImage: "负载均衡器镜像版本将由 <code>{from}</code> 升级到 <code>{to}</code>."
    form:
      name:
        placeholder: 例如:website
      description:
        placeholder: 例如:mycompany.com的负载均衡
  portsTab:
    title: 端口
    detail: '从主机IP映射到容器监听的端口。'
    notActive: 端口仅当服务处于活动状态时可见
  logTab:
    title: 服务日志
    detail: '这项服务最近发生的编排事件'
  type:
    service: 服务
    selectorservice: 选择器
    loadbalancerservice: 负载均衡
    dnsservice: 服务别名
    externalservice-ip: 外部 IP
    externalservice-host: 外部名称
    kubernetesservice: K8s 服务
    composeservice: Compose服务
    networkdriverservice: 网络服务
    storagedriverservice: 存储服务
  sidekick:
    tabHeader: 从容器
    header: 服务与从容器
    helpBlock: 服务的配置与该服务从容器的配置。
signupPage:
  header: '注册{appName}'
  form:
    button: 注册
    labels:
      loginUsername: 姓名
      email: 电子邮箱
  emailSuccess:
    header: '欢迎使用 {appName}'
    confirm:
      subtext: 已经发送邮件到您的邮箱，请点击邮件中的验证链接以确认您的邮件地址。
      resend: 重新发送邮件
stackPage:
  header:
    singleBanner: 查看单个应用
    backLink: 返回全部应用
  basics:
    tagsCopy: 复制用逗号分隔的标签
  containers:
    header: 容器
    detail: 应用中所包含的独立容器和服务。
    status: |
      {count, plural,
      =0 {没有容器}
      =1 {# 个容器}
      other {# 个容器}
      }
  loadBalancers:
    header: 负载均衡
    detail: '属于该应用的负载均衡容器。'
    status: |
      {count, plural,
      =0 {没有负载均衡}
      =1 {# 个负载均衡}
      other {# 个负载均衡}
      }
  dnsServices:
    header: DNS 条目
    detail: '属于该应用的DNS记录。'
    status: |
      {count, plural,
      =0 {没有记录}
      =1 {# 个记录}
      other {# 个记录}
      }
  scalingGroups:
    header: 扩容组
    detail: '属于该扩容组的容器'
    status: |
      {count, plural,
      =0 {没有容器}
      =1 {# 个容器}
      other {# 个容器}
      }
  volumesTab:
    header: 卷
    detail: '该应用挂载到容器中的卷。'
    table:
      path: 挂载点
      shared: 共享
      writable: 可写
      noData: 这个应用没有挂载任何卷
      noMatch: 没有匹配当前搜索的卷
newStack:
  header: 导入Compose.yml
  name:
    placeholder: '例如: myapp'
  description:
    placeholder: '例如: MyApp Stack'
  files:
    label: 额外的Compose文件
    addActionLabel: 添加Compose文件
    namePlaceholder: 文件名
    valuePlaceholder: 文件内容
  answers:
    label: 应答 (变量替换)
    addActionLabel: 添加应答
userPreferencesPage:
  header: 设置
  theme:
    header: 主题
    light: 明亮
    auto: 自动
    autoDetail: 自动设置会在晚6点到早6点间自动切换主题到黑色
    dark: 黑色
  generalInfo:
    header: 我的账号
    name:
      label: 姓名
    username:
      label: 用户名
    email:
      label: 邮件地址
processesPage:
  header: Processes
  tab:
    summary: 概览
    pools: 池
    running: 运行中
    delayed: 延迟
    ready: 就绪
    completed: 最近完成
  summary:
    noData: 当前没有进程被安排
    table:
      running: 运行中
      ready: 就绪
      delay: 延迟
  pools:
    noData: 当前没有进程池
    noMatch: 没有符合搜索条件的进程池
    table:
      activeTasks: 活跃
      poolSize: 池规格
      rejectedTasks: 已拒绝
      completedTasks: 已完成
      queueSize: 队列大小
      queueRemainingCapacity: 队列剩余
  list:
    table:
      resource: 资源
      exitReason: 退出原因
      startTime: 开始时间
      endTime: 结束时间
      runTime: 运行时间
      runAfter: 延迟运行
    noData: '当前没有{which}的进程'
    noMatch: 没有符合搜索条件的进程
verifyPage:
  header: "您已经成功验证了邮件地址!"
  subtext: 在完成您的账号设置前，我们还需要一些信息。
  account:
    header: 账号创建完成
    subtext: 点击以下链接登录
    linkText: 登录
verifyResetPasswordPage:
  header: 重置密码
  button: 更新密码
  success:
    header: 密码已重置!
    subtext: 点击以下链接返回登录页面
    linkText: 登录
waitingPage:
  hosts:
    setup:
      kubernetes: 设置Kubernetes
hostPartial:
  host:
    addCommon:
      quanity: 数量
ldap:
  providerName:
    openldap: OpenLDAP
    ad: 活动目录
  header:
    enabled:
      label: "{providerName} 已启用"
      required: |
        {appName} 已被设置为允许 {groups, plural,
        =0 {无组}
        =1 {# 个组}
        other {# 个组}
        } 和 {users, plural,
        =0 {无用户}
        =1 {# 个用户}
        other {# 个用户}
        }访问.
      restricted: |
        {appName} 已被设置为允许 {groups, plural,
        =0 {无组}
        =1 {# 个组}
        other {# 个组}
        } 和 {users, plural,
        =0 {无用户}
        =1 {# 个用户}
        other {# 个用户}
        }以环境成员身份访问.
      unrestricted: "{appName} 已设置为允许任何 {providerName} 用户访问。"
    disabled:
      label: "{providerName} 未设置"
      warning: "{appName} 可以设置为仅允许一组 {providerName} 用户和组访问。当前系统未设置，任何能够访问此页面或API的用户拥有对 {appName} 的完全控制权限。"
  accessEnabled:
    header: 验证
    subtext: "如需修改服务器配置，请在下方关闭访问控制后重新设置。"
    general:
      header: 常规
      server: "服务器:"
      tls: "TLS:"
      serviceAccount: "服务账号:"
      searchBase: "搜索起点:"
      defaultDomain: "缺省域:"
    users:
      header: 用户
      objectClass: "对象分类:"
      login: "登录字段:"
      name: "名称字段:"
      search: "搜索字段:"
      enabled: "启用字段:"
      disabledBitMask: "禁用位掩码:"
    group:
      header: 组
      objectClass: "对象分类:"
      name: "名称字段:"
      search: "搜索字段:"
    disable:
      header: "危险区域&trade;"
      warning: '<b class="text-danger">警告:</b> 禁用访问控制将导致任何能够访问此页面或API的用户拥有对  {appName} 的完全控制权限。'
      confirmDisable:
        pre: 关闭访问控制
        post: "确认? 再次点击将关闭访问控制。"
  accessConfig:
    header: "1. 配置 {providerName} 服务器"
    subtext1: "请输入地址、端口及协议以连接你的 {providerName} 服务器。<code>389</code> 是标准端口（未加密）, <code>636</code> 是加密连接（TLS）端口。"
    subtext2: "{appName} 需要一个对所有登录域有只读权限的服务账号"
    port:
      labelText: 端口
      checkbox: TLS
    groupSearchBase:
      labelText: '组搜索起点:'
      placeholder: "例如: ou=Groups,dc=mycompany,dc=com"
      helpText: "设置后，会在此搜索起点下搜索组而不会在用户搜索起点下搜索组."
    defaultDomain:
      helpText: "当用户未指定登录域时使用该域"
      labelText: 默认登录域
      placeholder: "例如:mycompany"
  customizeSchema:
    header: "2. 自定义架构"
    helpText: "如果你的活动目录架构(Schema)不是标准格式，可以在这里进行自定义设置。"
    users:
      header: 用户
      objectClass:
        labelText: 对象类型
      login:
        labelText: 登录字段
      name:
        labelText: 名称字段
      search:
        labelText: 搜索字段
      status:
        labelText: 状态字段
      disabledBitMask:
        labelText: 禁用状态位掩码
      userMemberAttribute:
        labelText: 用户成员属性
    groups:
      header: 组
      objectClass:
        labelText: 对象分类
      name:
        labelText: 名称字段
      search:
        labelText: 搜索字段
      groupMemberUser:
        labelText: 组成员用户属性
        placeholder: uid
      groupMemberMapping:
        labelText: 组成员映射属性
      groupDN:
        labelText: Group DN
  testAuth:
    header: "3. 测试并启用验证"
    helpText: "通过你的 {providerName} 账号进行验证测试以确认配置是否正确:"
    userName:
      labelText: 你的用户名
    password:
      labelText: 你的密码
    authenticate:
      pre: 验证
      post: "测试中..."
servicePartial:
  noContainers:
    label: 没有容器
    inactive:
      start: 启动
accordionRow:
  status:
    none: 无
    incomplete: 未完成
    error: 错误
    notConfigured: 未设置
    configured: 已设置
    countConfigured: "{count}已设置"
    standard: 默认
    custom: 自定义
    specific: 具体
    any: 任何
    rule: "{count, plural, =1 {# 个规则} other {# 个规则}}"
advancedSection:
  showText: 显示高级选项
  hideText: 隐藏高级选项
billingInfo:
  header: 账单信息
  addNew: 添加支付方式
  noSub: 你尚无可用的付款方式
  table:
    title:
      cardType: '信用卡类型: {brand}'
      last4: '卡号末4位: {last}'
      exp: '有效期: {exp}'
      name: '持卡人姓名: {name}'
      actions: 操作
caasLogin:
  resetHeader: 重置密码
  new: 创建账号
  reset: 重置密码
  resetSuccess: 成功！检查您的邮件以获取重置密码链接。
  error: 获取邮箱时出错，请确认您的邮件地址设置并重试。
  invalidEmail: 你输入不是一个有效的邮件地址。请输入一个有效的邮件地址，然后重试。
  login: 登录页面
  form:
    email: 邮箱
catalogSettings:
  certified:
    header:
      rancher: "{appName} 认证库"
      pl: 认证的库
    detail:
      rancher: Rancher核心功能所依赖的模板，例如Kubernetes/Mesos/Swarm编排支持。由Rancher官方维护并提供支持。
      pl: 由官方维护的核心功能所需要的模板，例如Kubernetes/Mesos/Swarm等
  community:
    header:
      rancher: 社区贡献
      pl: 社区贡献
    detail:
      rancher: 由社区成员创建并维护的模板 未经过Rancher Labs认证
      pl: 由社区成员创建并维护的模板
  more:
    header: 更多
    addActionLabel: 添加应用商店
    name:
      label: 名称
      placeholder: 例如 mycatalog
    url:
      label: URL
      placeholder: '例如 https://github.com/mycompany/mycatalog.git'
    kind:
      label: 类型
      native: 原生
    branch:
      label: 分支
      placeholder: '例如 master'
clusterRow:
  noMatch: 没有匹配当前搜索的环境。
  noData: 集群中还没有任何环境。
  noClusterMatch: 没有匹配当前搜索的集群。
  noClusterData: 没有任何集群。
  importCluster: 使用已有的Kubernetes
  loginDefault: 登陆
clusterWelcome:
  welcome: 欢迎
  noHost: 集群中还没有任何主机。您想要添加主机还是使用已有的Kubernetes呢?
  select: 选择
  importCluster: 使用已有的Kubernetes
  importClusterDescription: |
    <p>部署容器到已有的Kubernetes环境，并使用它的主机和网络。</p>
    <p>基础设施资源将在{appName}外部进行管理。</p>
    
    <p>支持本地部署的K8S，或者类似以下的托管的K8S服务:</p>
  embeddedDescription: |
    <p>{appName}将自动部署并且管理Kubernetes。</p>
    <p>可以在{appName}界面上，部署主流云厂商提供的云主机，或者用已有的安装有Docker的任何主机。</p>
    <p>支持虚拟机和物理机，支持本地主机也支持云主机。</p>
    <p>为容器提供安全的Overlay网络，使容器相互之间可以安全的进行跨主机通信。</p>
confirmDelete:
  title: '是否确认要删除'
  protip: 高级技巧:在点击删除时按住 {key} 键以跳过确认操作。
  confirmAction: 删除
  cancelAction: 取消
  largeDeleteText: '{key} 及 {othersCount} 其他'
containerLogs:
  title: '日志: {instanceName}'
  onlyCombined: "<b>注意:</b> 此容器运行时带有TTY(-t)参数，仅有合并的标准输出和标准错误日志可见"
  combined: 合并日志
  stdout: 标准输出
  stderr: 标准错误
  protip: '高级技巧: 点击查看日志时按住 {key} 键在新窗口中打开'
  scrollTop: 回到顶部
  scrollBottom: 回到底部
  clear: 清除屏幕
  status:
    initializing: 初始化...
    connecting: 连接中...
    connected: 已连接
    disconnected: 已断开
    closed: 已关闭
containerShell:
  protip: '高级技巧: 点击运行命令行时按住 {key} 键在新窗口中打开'
  status:
    initializing: 初始化...
    error: 错误:{error}
    connecting: 连接中...
    connected: 已连接
    disconnected: 已断开
    closed: 已关闭
copyToClipboard:
  tooltip: 复制到剪贴板
  copied: 已复制
dangerZone:
  header: 高级设置
  showLabel: 我确认已经知道修改高级设置可能导致问题
devicePermissions:
  all: 全部
  none: 无
  read: 读
  write: 写
editAccount:
  title: 编辑账号
  form:
    name:
      placeholder: 例如:John Smith
    kind:
      label: 账号类型
    description:
      label: 描述
      placeholder: 例如:John Smith的账号
    oldPassword:
      label: 当前密码
    newPassword:
      label: 新密码
    confirmPassword:
      label: 确认密码
    identity:
      label: 标识
editApiKey:
  title:
    justCreated: API Key已创建
    editing: 编辑API Key
    new: 新建API Key
  publicValue:
    label: Access Key (用户名)
  secretValue:
    label: Secret Key (密码)
  name:
    placeholder: 例如:App servers
  description:
    placeholder: 例如:用于app server部署容器
  saveWarning1: 请保存上面的Key！Secret Key仅显示一次
  saveWarning2: 如果忘记了Secret Key，您需要重新创建新的API Key
  noteOptional: 名称和描述均为可选项（有助于记录API Key的用途），您可以直接点击创建按钮。
editCertificate:
  title: 编辑证书
  name:
    placeholder: 例如:mydomain.com
  description:
    placeholder: 例如:mydomain.com的EV证书
  noteKeyWriteOnly: 注意:Private Key部分为只写(write only)因而显示为空白。更新证书时您需要重新上传Private Key，即便Private Key未发生变化。
editCluster:
  title:
    new: 添加集群
    edit: 编辑集群
  name:
    label: 名称
    placeholder: 例如 Sandbox
  description:
    label: 描述
    placeholder: 例如 开发人员所共享的集群
  systemStacks:
    hr: 集群选项
    title: 系统应用
    detail: 这些应用将会被自动部署到该集群的System环境中。
    noData: 没有应用将会被部署到系统环境中。
    add: 添加应用
    cancel: 取消添加系统应用
  modal:
    onCluster: '注意: 您正在尝试删除您当前环境所在的集群。请在删除该集群之前，先选择一个其他集群的环境。'
editContainer:
  title:
    vm: 编辑虚拟机
    container: 编辑容器
  name:
    placeholder: 例如:myapp
  description:
    placeholder: 例如:我的应用
editHost:
  title: 编辑主机
  hostname:
    label: 主机名
  customName:
    label: 自定义名称
    placeholder: 例如:dev1
    help: 如果此处未设置，名称将显示为主机名
  description:
    label: 描述
  labels:
    label: 标签
  ips:
    label: 调度IP
    valueLabel: IP地址
    valuePlaceholder: '例如: 1.2.3.4'
    addActionLabel: 添加IP
    help: 如果设置，调度器将从中选择一个IP地址并将发布的端口绑定到该地址。
  requireAny:
    label: 容器标签需求
    addActionLabel: 添加标签需求
editRegistry:
  title: 编辑镜像库
  address:
    label: 地址
  email:
    label: 邮箱
    placeholder: 例如:you@example.com
  username:
    label: 用户名
    placeholder: 例如:username
  password:
    label: 密码
    placeholder: 例如:password
editService:
  title: 编辑服务
editStack:
  name:
    label: 名称
    placeholder: 例如:myapp
  description:
    label: 描述
  group:
    label: 标签
    placeholder: '例如: frontend, production'
envCatalog:
  header: 管理应用商店
  addActionLabel: 添加应用商店
stackHeader:
  outputs: 输出
stacksPage:
  table:
    standalone: 独立容器
    endpoints: 终端
    scale: 伸缩
    instanceState: 容器状态
    instanceStateWithIcon: 状态
formatIp:
  noIp: 无
formBalancerConfig:
  title: 自定义配置文件
  detail: 提供您的自定义配置文件，这个配置将会被应用到{appName}自动生产的配置上方。
  config:
    prompt: 自定义haproxy.cfg内容
formBalancerListeners:
  label: 监听器与目标规则
  detail: 配置负载均衡，使其将请求转发到目标地址。
  status: |
    {count, plural,
    =0 {没有规则}
    =1 {# 个规则}
    other {# 个规则}
    }
  noRules: 没有端口
  addPortLabel: 添加一个监听端口
  removePortLabel: 删除这个监听端口
  showBackendLabel: "自定义backend名称"
  access:
    label: 访问
    public: 公开
    internal: 内部
  protocol:
    label: 协议
  sourceIp:
    label: 主机IP
    placeholder: '例如 1.2.3.4; Default: All'
  sourcePort:
    label: 监听端口
    placeholder: 例如 80
  help: "主机及路径规则将根据显示的顺序自上而下进行匹配。后端默认将随机命名。要自定义生成的后端，提供一个名称并在你自定义的 haproxy.cfg 文件中引用该名称。 "
formBalancerRules:
  label: 目标规则
  detail: 根据主机、 端口、 路径或 IP 地址映射请求到不同的目标。
  status: |
    {count, plural,
    =0 {没有规则}
    =1 {# 个规则}
    other {# 个规则}
    }
  noRules: 无规则
  addServiceLabel: 添加服务
  addInstanceLabel: 添加容器
  addSelectorLabel: 添加选择器
  addTargetLabel: 添加规则
  access:
    label: 访问
    public: 公开
    internal: 内部
  protocol:
    label: 协议
  sourceIp:
    label: 主机IP
    placeholder: 例如：1.2.3.4; 默认： 所有
  sourcePort:
    label: 监听端口
    placeholder: 例如 80
  path:
    label: 路径
    placeholder: 例如 /foo
  hostname:
    label: 请求头信息
    placeholder: '例如: example.com'
  backendName:
    label: 后端
    placeholder: '例如: webapp'
  targetPort:
    label: 端口
    placeholder: '例如: 80'
  priority:
    label: 优先级
  target: 目标
  selector:
    label: 选择器
    placeholder: '例如: foo=bar'
formCommand:
  title: 命令
  detail: 配置容器启动时将运行的可执行文件。
  command:
    label: 命令
    placeholder: 例如:/usr/sbin/httpd -f httpd.conf
  entryPoint:
    label: 入口
    placeholder: 例如:/bin/sh
  environment:
    label: 环境标签
  workingDir:
    label: 工作目录
    placeholder: 例如:/myapp
  console:
    label: 控制台
    both: '交互 &amp; TTY终端 <span class="text-muted">(-i -t)</span>'
    interactive: '交互 <span class="text-muted">(-i)</span>'
    terminal: 'TTY终端 <span class="text-muted">(-t)</span>'
    none: 无
  autoRestart:
    label: 自动重启
    no: 从不
    onFailure: '失败时 <span class="text-muted">(非0退出代码)</span> 总是'
    onFailureCondPrefix: 失败时，最多
    onFailureCondSuffix: |
      {limit, plural,
      =1 {次}
      other {次}
      }
    always: 总是
formContainerLinks:
  title: 链接
  detail: 定义此容器和其他容器的关联关系
  addActionLabel: 添加链接
  name:
    label: 目标容器
  alias:
    label: 名称
    placeholder: 例如:database
  noData: 没有容器链接
  noMatch: 没有匹配当前搜索的链接
formCount:
  label: 数量
formDisks:
  addDiskLabel: 添加磁盘
  addRootDiskLabel: 添加根磁盘
  name:
    rootDisk: 根磁盘
    label: 名称
    placeholder: 例如:data
  size:
    label: 大小
    rootDisk: 由系统镜像决定
  readIops:
    label: 读IOPS
    placeholder: '例如: 1000'
  writeIops:
    label: 写IOPS
    placeholder: '例如: 1000'
  driver:
    label: 驱动
formEngineOpts:
  engineInstallUrl:
    label: Docker安装URL
    placeholder: 例如:http://get.docker.com
    recommended: 推荐
    latest: 最新
  engineStorageDriver:
    label: 存储驱动
    placeholder: 例如:overlay
  engineOpts:
    label: 引擎选项
    addActionLabel: 添加引擎选项
    keyPlaceholder: 例如:log-driver
    valuePlaceholder: 例如:syslog
  engineLabels:
    label: 引擎标签
    addActionLabel: 添加引擎标签
    keyLabel: 标签
  engineEnv:
    label: 引擎环境
    addActionLabel: 添加环境变量
    keyLabel: 变量
    keyPlaceholder: 例如:HTTP_PROXY
    valuePlaceholder: 例如:http://your-proxy:8080
  engineInsecureRegistry:
    label: 非安全镜像库
    addActionLabel: 添加非安全镜像库
    valueLabel: 镜像库域名
    valuePlaceholder: 例如:registry.example.com
  engineRegistryMirror:
    label: 镜像库镜像
    addActionLabel: 添加镜像库镜像
    valueLabel: 镜像URL
    valuePlaceholder: 例如:https://my-mirror.example.com:5000
formEnvVar:
  title: 环境变量
  detail: 在创建时添加的环境变量。
  noData: 没有环境变量
  status: |
    {count, plural,
    =0 {尚未配置}
    =1 {# 个变量}
    other {# 个变量}
    }
  labels:
    key: 键
    value: 值
formHealthCheck:
  title: 健康检查
  checkType:
    none: 无
  host:
    label: 主机头信息
  port:
    placeholder: 例如:80
  reinitializingTimeout:
    label: 重新初始化超时
formKeyValue:
  addAction: 添加键值对
  key:
    label: 键
    placeholder: 键
  separator: "="
  value:
    label: 值
    placeholder: 值
  protip: '高级技巧: 在键(Key)输入栏中粘贴一行或多行的key=value键值对能够批量输入。'
formImage:
  label: Docker镜像
  container:
    placeholder: "例如: ubuntu:xenial"
formNameDescription:
  name:
    label: 名称
    placeholder: 名称
  description:
    label: 描述
    placeholder: 描述
    expand: 添加描述
formNetwork:
  title: 网络
  detail: 设置容器的网络和DNS选项
  networkMode:
    label: 网络
    bridge:
      label: 桥接
      detail: 连接到默认Docker0网桥
    default:
      label: 默认
      detail: 默认的网络
    container:
      label: 容器
      detail: 连接到已有容器的网络命名空间
    host:
      label: 主机
      detail: 连接到主机的网络命名空间
    managed:
      label: 托管
      detail: 自动创建的容器间网格网络
    sidekick:
      label: 从容器
      detail: 与主服务的网络模型相同
    nat:
      label: NAT
      detail: 主机网络的网络地址转换
    ipsec:
      label: IPSec
    transparent:
      label: 透传
      detail: 直接连接到物理网络
    none:
      label: 无
      detail: 无网络
  container:
    label: 容器
  requestedIp:
    label: 请求IP
    placeholder: 例如：10.42.2.24
    help: 从10.42.0.0/16段中请求一个指定的IP地址，如果此IP地址已经被使用则会分配一个随机IP。
  retainIp:
    label: 保持IP
    reuse: 当升级或替换不健康的容器实例时保持IP地址不变。
  dns:
    label: 服务发现
    enable: 启用服务发现并使用本地缓存DNS服务器
    disable: 禁用服务发现并使用外部远端DNS服务器
  hostname:
    label: 主机名
    placeholder: '例如: web'
    dockerId: 使用Docker容器ID
    hostName: 使用主机的主机名
    containerName: 使用容器名称
    custom: 设置主机名
  domainName:
    label: 域名
    placeholder: '例如: example.com'
  resolvingServers:
    label: 解析服务器
    addActionLabel: 添加服务器
    placeholder: '例如: 8.8.4.4'
  searchDomains:
    label: 搜索域
    placeholder: '例如: prod.example.com'
    addActionLabel: 添加搜索域
formPorts:
  header: 端口映射
  addAction: 添加端口
  protocol:
    label: 协议
  noPorts: 当前容器没有端口映射
  error:
    privateRequired: 每条端口规则必须有私有容器端口
    publicRequired: 指定主机IP时必须设置公开主机端口
    mixedIpPort: "Port {ip}:{port}/{proto} 有超过一条映射规则"
    mixedPort: "Port {port}/{proto} 有超过一条映射规则"
  showIpLink: 自定义主机IP选项
formScale:
  label: 伸缩
  showAdvanced: 伸缩选项
  mode:
    sidekickPrefix: '从容器: 数量和调度规则遵照'
formScheduling:
  status: |
    {count, plural,
    =0 {没有规则}
    =1 {# 个规则}
    other {# 个规则}
    }
  condition: 条件
  field: 字段
  value: 值
  scaling:
    minMaxDetail: 如果设置，用户将无法通过界面或API请求使容器数量低于最小数量或超过最大数量。
    incrementDetail: 如果设置，容器数量必须是它的倍数。
    hostMaxDetail: 如果设置，容器将最多被运行在这个数量的主机上。
  scaleMin: 最小数量
  scaleMax: 最大数量
  scaleIncrement: 伸缩增量
  perHost: 每个主机
formSecrets:
  title: 密文
  detail: 密文允许将密码、秘钥或其他敏感信息注入到需要使用的容器中
  noneDefined: 无密文可用
  noData: 无密文设置
  addLabel: 添加密文
  name:
    label: 映射名称
    placeholder: '例如: db_password'
  secret:
    label: 密文
  uid:
    label: 用户ID
    placeholder: '例如: 0 (root)'
  gid:
    label: 组ID
    placeholder: '例如: 0 (wheel)'
  mode:
    label: 文件权限 (八进制)
    placeholder: '例如:  0444 (八进制)'
  help:
    prefix: "密文将以指定的文件名映射到容器内的 <code>/run/secrets/</code> 的目录下。"
    showPermissionsLink: "自定义文件所有者及权限"
formSecurity:
  title: 安全及主机设置
  detail: 授予或限制容器影响所运行主机的能力
  pullImage:
    label: 拉取镜像
  privileged:
    label: 特权
    enable: '有: 容器有完全主机访问权限'
  memoryLimit:
    unlimited: 无限制
    set: 限制为
  swapLimit:
    label: 交换内存
    unlimited: 无限制
    set: 限制为
    default: 限制为两倍物理内存
    none: 不允许使用交换内存
  swappiness:
    label: Swappiness
    default: 使用主机的默认值
    none: 最小
    set: 自定义 (1-100)
  cpuPinning:
    label: CPU 绑定
    placeholder: '例如: 0,1,3; 默认: All'
  shares:
    label: CPU份额
    placeholder: '例如: 1024'
  capabilities:
    add: 增加内核能力
    drop: 移除内核能力
    helpBlock:
      text: 内核能力能够对容器所拥有的超级用户权限进行更细粒度的控制.
      link: 更多信息
  deviceBinding:
    label: 设备绑定
    addActionLabel: 添加绑定
    pathHost:
      label: 主机内路径
      placeholder: '例如: /dev/sdc'
    pathContainer:
      label: 容器内路径
      placeholder: '例如: /dev/xsdc'
    permissions:
      label: 权限
  memoryReservation:
    label: 内存预留
  milliCpuReservation:
    label: CPU预留
  isolation:
    label: 隔离
    default: 默认 (容器)
    hyperv: HyperV (虚拟机)
formServiceLinks:
  title: 链接
  detail: 定义这个服务和其他服务之间的关系。
  addAction: 添加链接
  service:
    label: 目标服务
  name:
    label: 名称
    placeholder: 例如:database
formSslTermination:
  title: SSL/TLS 证书
  detail: 配置即将应用于加密端口请求的证书。
  defaultCertificate:
    prompt: 选择一个证书...
  alternateCertificate:
    prompt: 选择一个证书...
  certificate: 证书
  alternateCerts: 备选证书
  addAlternate: 添加备选证书
  noCertificates: 没有可用的证书。
  noAlternateCertificates: 没有其他可用的证书。
  helpBlock: |
    "注意: 一些旧的 SSL/TLS 客户的不支持 <a href="https://en.wikipedia.org/wiki/Server_Name_Indication" target="_blank">Server Name Indication (SNI)</a> 功能，对于这些客户端将只提供主证书。 对于支持SNI功能的现代客户端将根据匹配结果从备选证书列表中选择一个合适的证书。"
  notNeeded: 没有配置了有效的目标规则的 SSL/TLS 的监听端口。
formStickiness:
  title: 目标路由
  detail: 配置负载均衡将请求转发到指定的同一个容器或者到与该负载均衡所在主机相同的容器。
  balancerTarget: 目标容器设定
  any: 将请求发送到任何主机上的健康目标容器。
  preferLocal: 优先选择与负载均衡所在主机相同的容器。（如果该主机找不到健康的容器，则将请求发送到其他主机上）
  onlyLocal: "仅选择与负载均衡所在主机相同的容器。（如果该主机找不到健康的容器，则返回响应<code>503</code>）"
  sticky: 会话保持
  none: 无
  newCookie: 负载均衡定义会话保持 cookie
  cookieName: Cookie名称
  mode: 模式
  domain: 域名
  options: 选项
  indirect: 间接
  sendHeader: 发送no-cache头
  onPost: 仅对POST请求设置Cookie
  noPorts: 没有配置了 HTTP 监听器的有效目标规则。
  placeholder:
    sticky: '例如: sticky'
    domain: '例如: mydomain.com'
formTargets:
  title: 目标
  addAction: 添加目标
  hostname:
    label: 请求头信息
    placeholder: 例如:svc.com
  srcPort:
    label: 源端口
    placeholder: 例如:80
  value:
    label: 目标服务
  path:
    label: 请求路径
    placeholder: '例如: /svc'
  dstPort:
    label: 目标端口
    placeholder: 例如:8080
  advanced:
    toggle: 显示高级路由选项
    detail: 根据端口、主机头或请求路径等信息将请求转发到不同服务
    help1: |
      如果指定了请求主机和/或路径，HTTP监听端口上的连接将会被路由到基于请求的合适目标。
      例如，您可以使用此设置根据请求主机信息domain1.com 和 domain2.com将访问发送到不同服务，或者将 domain3.com/admin的访问发送到一个不同的服务上。
    help2: |
      匹配的请求将会被发送到目标服务的目标端口。
      如果目标端口未设置，将使用缺省目标端口。如果缺省目标端口也未设置，将使用源端口。
formUserData:
  placeholder: "例如: 容器的配置信息"
  isVmPlaceholder: "例如: 虚拟机的配置信息"
formUserLabels:
  title: 标签
  detail: 标签是可用于注释容器并进行调度决策的键值对
  hostDetail: 键/值对形式的标签将应用于主机上，用于容器的调度决策。
  addAction: 添加标签
  key:
    label: 键
    placeholder: '例如: foo'
  separator: "="
  value:
    label: 值
    placeholder: 例如:bar
  protip: '高级技巧: 粘贴一行或多行的 key=value键值对能够批量输入。'
formUpgrade:
  title: 更新策略
  detail: 配置升级过程中替换容器的策略。
  batchSize:
    label: 批量大小
    detail: 这么多容器都将被一起替换。
  interval:
    label: 批量间隔
    detail: 在完成一次批量替换和开始下一轮的替换之间的时间间隔。
  behavior: 替换行为
  startFirst:
    label: 先启动新的，再停止旧的
    detail: 停止旧容器之前先启动新容器。如果服务暴露了端口，必须有足够的可用主机能够启动指定数量的容器，因为旧的容器仍然占用着原有主机的端口。
  stopFirst:
    label: 先停止旧的，再启动新的
    detail: 停止旧容器（根据批量大小），然后启动新的容器。这样容器可以重用主机端口。可以通过修改批量大小来，来确保应用可以在升级过程中提供足够的服务能力。
  prePull:
    label: 预拉取镜像
    detail: 镜像可以在升级启动之前被预拉取到主机上，以便最小化启动新容器所造成的中断。
    all: 在所有主机上
    existing: 在服务当前所在的主机上
    none: 不在任何主机上
formValueArray:
  addActionLabel: 添加值
  valueLabel: 值
  valuePlaceholder: 值
  protip: '高级技巧: 在任意输入栏中粘贴一行或多行的 value能够批量输入。'
formVolumeRow:
  mode:
    volume: 已有的卷
    newVolume: 新建卷
    bindMount: 挂载
    volumesFrom: 卷来自
    volumesFromLaunchConfig: 卷来自
    custom: 自定义
  edit: 修改
  tmpfsSource: 内存
  hostPath:
    label: 主机路径
    placeholder: 例如 /home/foo
  mountPoint:
    label: 挂载点
    placeholder: 例如 /mnt/foo
  volume:
    prompt: 选择一个卷...
  volumesFrom:
    prompt: 选择一个容器...
  volumesFromLaunchConfig:
    prompt: 选择一个配置...
  custom:
    placeholder: 自定义--volume值
  opts:
    ro: 只读
    rw: 读写
    custom:
      label: 自定义
      placeholder: 例如 rw,z
formVolumes:
  title: 卷
  detail: 持久化及共享数据并与独立容器的生命周期分离
  value:
    prompt: 选择一个容器...
  volumes: 卷
  volumesFrom: 卷来自
  volumeDriver:
    label: 卷驱动
    placeholder: '例如: rancher-nfs; 默认: local'
    suggestion: '使用的存储驱动:'
  noLaunchConfigs: 此服务下没有可共享卷的启动配置.
  noHostContainers: 该主机没有可以提供共享卷的容器.
  onlySingleHost: 仅当添加容器到特定主机时适用.
  errors:
    incomplete: 尚未完成卷定义
    absoluteMountPoint: 卷挂载点必须使用绝对路径。
  add:
    label: 添加卷...
    existing: 使用一个现有的卷
    new: 创建一个新的卷
    bindMount: 挂载一个主机目录
    fromContainer: 使用其他容器的卷
    fromLaunchConfig: 使用从容器的卷
    tmpfs: 添加一个内存中的tmpfs
    custom: 添加自定义卷
  table:
    kind: 类型
    source: 源
    mountPoint: 挂载点
    opts: 权限/选项
hookPage:
  receiver:
    header: 接收的钩子
    buttonText: 添加接收器
    content: "Receiver hooks 提供一个URL，在访问该URL时能够触发{appName}内部相应的动作。"
    noData: 无receiver hooks.
  scaleService:
    label: 扩缩容服务
    detailPrefix: "扩缩容动作 {action} "
    detailSuffix: "以步长 {amount}"
  scaleHost:
    detail: "符合标签 {labels} {action} 以步长 {amount}"
  serviceUpgrade:
    label: 升级服务
    detail: "符合标签 {labels} 当 <code>{tag}</code> 变化时"
  fields:
    kind:
      label: 类型
    detail:
      label: 详情
    url:
      label: 触发地址
hostSettings:
  header: 主机注册URL
  subtext: 主机连接{appName} API的Base URL是？
  hostUrl:
    local: "当前站点地址:"
    new:
      labelText: "其他地址:"
      placeholder: "例如:http://example.com:8080"
  helpText:
    static1: "不要包含 <code>/v1</code> 或任何其他路径，但如果你设置了"
    static2: "在 {appName} 前面，请确保使用<code>https://</code>."
    isRancher: '<a href="{docsBase}/installing-rancher/installing-server/basic-ssl-config/" target="_blank">SSL Termination(SSL终止) </a>'
    sslTerm: SSL终止
  notPublic:
    alert: |
      确定要创建的所有主机都能够连接 <code>{activeValue}</code> ？<br/> 当前地址似乎是私有IP或内部网络。
  badTld:
    alert: |
      '<code>.local</code> 顶级域名根据RFC6762被保留为用于多播DNS。不推荐使用.local域名作为注册URL，该设置可能导致DNS解析问题。请选择其他的主机名或者IP地址。'
hostPod:
  supportState:
    unsupported: 不支持的Docker版本
    untested: 未测试Docker版本
  groupedInstances:
    namespace: '命名空间:'
    stack: '应用:'
    standalone: 独立容器
identityBlock:
  loading: 加载中...
infoMultiStats:
  connecting: 连接中...
  utilizationStats: 使用率统计数据仅在活动/运行时可见
  cpuSection:
    system: 系统
    user: 用户
  networkSection:
    labelText: 网络
    transmit: 发送
    receive: 接收
  memorySection:
    labelText: 内存
    used: 已使用
  storageSection:
    labelText: 存储
    read: 读
    write: 写
inputIdentity:
  placeholder:
    github: 添加GitHub用户或组织名称
    generic: 添加用户名或组名
  dropdownLabel:
    teams: 你的团队和组织
    groups: 你的组
inputPassword:
  buttonText: 生成
inputTextFile:
  tooltip: 从文件读取
labelsSection:
  kind: 类型
  title: 标签
  detail: 键／值可以被用在主机调度规则里和一些其他的高级设置中。
  status: |
    {count, plural,
    =0 {无标签}
    =1 {# 个标签}
    other {# 个标签}
    }
  key: 键
  value: 值
  noData: 无标签
loginShibboleth:
  buttonText: 通过Shibboleth验证
loginGithub:
  buttonText: 通过GitHub验证
loginUserPass:
  userLabel: 用户名
  caasLabel: 邮箱
  userPlaceholder: 例如:jsmith
  loginLabel: 登录
  loggingInLabel: 登录中...
  passwordLabel: 密码
machine:
  driver:
    other: 其他
    custom: 自定义
    aliyunecs: 阿里云
  driverAmazon:
    accessSection: 账户访问
    accessKey:
      placeholder: 你的AWS access key
    secretKey:
      placeholder: 你的AWS secret key
      provided: 已提供
    region:
      label: 区域
    accessKeyHelp: "在此粘贴你的AWS密钥对，我们将用秘钥创建新的实例。"
    loginAction: 下一步:验证及选择网络
    loadingAvailability: 从EC2加载可用区和VPC信息...
    vpcSection: 可用区 & VPC
    availabilityZone: 可用区
    securityGroupSelect: 下一步:选择安全组
    loadingSecurity: 从EC2加载安全组信息...
    securityGroupSection: 安全组
    securityGroup:
      label: 安全组
      choose: 选择一个存在的安全组
      defaultExisting: 标准:使用现有的 <code>{groupName}</code> 安全组
      defaultCreate: 标准:自动创建新的 <code>{groupName}</code> 安全组
      custom: 自定义:选择现有安全组
      updating: 更新安全组...
      creating: 创建安全组...
    portHelp:
      link: 了解更多
      text: 关于将要开放的端口信息
    needs:
      label: "{appName} 正常工作需要安全组允许以下通讯:"
      item1: 从 {appName} 服务器到主机的 <code>TCP</code> 端口 <code>22</code> <span class="text-muted">(SSH连接以安置配置Docker)</span>
      item2: 与其他所有主机之间的 <code>UDP</code> 端口 <code>500</code> 和 <code>4500</code> <span class="text-muted">(用于IPsec网络)</span></li>
      item3: 这些规则 <b>不会</b> 被自动添加
    setInstanceAction: 下一步:设置实例选项
    instanceSection: 实例
    instanceOptionsSection: 实例选项
    instanceType:
      label: 实例类型
    rootSize:
      label: 根分区硬盘大小
    ami:
      label: Amazon系统映像(AMI)
      placeholder: Ubuntu AMI
      rancherList: RancherOS AMI列表
    sshUser:
      label: SSH用户
      placeholder: 例如:ubuntu
    iam:
      label: IAM配置文件
    privateIp:
      label: 私有IP
    onlyPrivate:
      label: 仅使用私有IP地址
  driverAzure:
    helpBlock: '参考<a href="https://www.packer.io/docs/builders/azure-setup.html" target="_blank">链接文档</a>创建客户端ID和秘钥'
    accountAccessSection: 账户访问
    placementSection: 位置
    networkSection: 网络
    subscriptionId:
      label: 订阅ID
      placeholder: Azure订阅ID
    instanceSection: 实例
    instanceOptionsSection: 实例选项
    image:
      label: 镜像
    size:
      label: 规格
    dockerPort:
      label: Docker端口
      placeholder: '例如:2376'
    publishSettingsFile:
      label: 发布配置
      placeholder: 发布配置文件
    environment:
      label: 环境
    resourceGroup:
      label: 资源组
      placeholder: 'docker-machine'
    sshUser:
      label: SSH用户
    storageType:
      label: 存储类型
    subnet:
      label: 子网名称
      placeholder: 示例别名
    subnetPrefix:
      label: 子网Prefix
      placeholder: 128.42.0.0/21
    availabilitySet:
      label: 可用性集
      placeholder: 可用集名称
    openPort:
      label: 开放端口
      placeholder: '逗号分隔, 例如: 80,443'
    privateIpAddress:
      label: 私有IP
      placeholder: 127.0.0.1
    usePrivateIp:
      label: 使用私有IP连接
    staticPublicIp:
      label: 公网IP
    noPublicIp:
      label: 无公网IP
    clientId:
      label: 客户端ID
      placeholder: 您的客户端 ID
    clientSecret:
      label: 客户端秘钥
      placeholder: 你的客户端秘钥
    region:
      label: 区域
  driverCustom:
    instructions: '复制，粘贴，并且运行下面的命令来注册一台主机。该主机需要运行{appName}<a href="{docsBase}/hosts/#supported-docker-versions" target="_blank">支持的Docker版本</a>。执行成功后，主机将会显示出来。'
    detail:
      ip: 主机的IP地址正常情况下会被自动检测出来。
      ipLabel: 主机IP地址
      manual: '如果主机位于防火墙/NAT设备之后，或者主机同时也是运行<code>{rancherImage}</code>容器的主机时，您可能需要在下面的高级选项中设置主机IP。'
      firewall: 主机会与服务器创建连接，所以请保证防火墙或者安全组允许主机访问命令行中的地址。
      networking: 环境中的全部主机相互之间都要可达，从而进行跨主机通信。请根据您要使用的网络组件开通相应端口。
      ipsec: 'IPSec: <code>500/udp</code> 和 <code>4500/udp</code>'
    detected: |
      {count, plural,
      =1 {一台新主机注册成功!}
      other {# 新主机注册成功!}
      }
    agentIp:
      label: 指定当前主机在集群中的IP地址。如果为空，系统将自动探测IP。
      placeholder: '例如: 1.2.3.4'
    generating: "生成注册URL..."
    windows:
      windowsHeader: Windows主机
      linuxHeader: Linux主机
      step2: "创建一个 transparent Docker 网络:"
      step3: 复制粘贴下面的命令到Powershell命令行中运行以启动 {appName} agent
  driverDigitalocean:
    accountSection: 账户访问
    authAccountButton: '下一步: 配置 Droplet'
    accessToken:
      label: 访问令牌
      placeholder: 你的DigitalOcean API访问令牌
      help: |
        由<a href="https://cloud.digitalocean.com/settings/applications" target="_blank">Apps & API</a>
        页面获取的DigitalOcean个人访问令牌
    instanceSection: 实例
    instanceOptionsSection: 实例选项
    image:
      label: 镜像
    sshUser:
      label: SSH 用户
    size:
      label: 大小
    regionSection: 区域
    region:
      label: 区域
    optionsSection: 选项
    backups:
      label: 启用备份
    ipv6:
      label: 启用IPv6
    privateNetworking:
      label: 启用私有网络
  driverExoscale:
    accountSection: 账户访问
    apiKey:
      label: API Key
      placeholder: 你的Exoscale API Key
    secretKey:
      label: 加密秘钥
      placeholder: 你的Exoscale secret key
      provided: 已提供
    accountHelp: 在此粘贴你的Exoscale密钥对，我们将用秘钥创建新的实例。
    loginAction: 下一步:验证及选择安全组
    loadingSecurity: 从Exoscale加载安全组...
    securityGroupSection: 安全组
    securityGroup:
      label: 安全组
      defaultExisting: 标准:使用现有的 <code>{groupName}</code> 安全组
      defaultCreate: 标准:自动创建 <code>{groupName}</code> 安全组
      custom: 自定义:选择现有安全组
      updating: 更新安全组...
      creating: 创建安全组...
    portHelp:
      link: 了解更多
      text: 关于将要开放的端口信息
    needs:
      label: "{appName} 正常工作需要安全组允许以下通讯:"
      item1: 从 {appName} 服务器到主机的 <code>TCP</code> 端口 <code>22</code> <span class="text-muted">(SSH连接以安装配置Docker)</span>
      item2: 与其他所有主机之间的 <code>UDP</code> 端口 <code>500</code> 和 <code>4500</code> <span class="text-muted">(用于IPsec网络)</span>
      item3: 这些规则 <b>不会</b> 被自动添加
    selectSecurityGroupAction: 下一步:设置实例选项
    loadingInstance: 读取可用实例配置...
    instanceSection: 实例
    instanceOptionsSection: 实例选项
    instanceProfile:
      label: 实例配置文件
    diskSize:
      label: Root大小
    sshUser:
      label: SSH 用户
  driverOther:
    driverSection: 驱动
    driver:
      label: 驱动
    optionsSection: "{driverName} 选项"
    instanceSection: 实例
  driverPacket:
    accountSection: 账户访问
    projectId:
      label: 项目
      placeholder: 你的Packet项目ID
    apiKey:
      label: API 密钥
      placeholder: 你的Packet API Key
    apiKeyHelp: '由Packet的 <a href="https://app.packet.net/portal#/api-keys" target="_blank">API Keys</a> 页面获取'
    instanceSection: 实例
    instanceOptionsSection: 实例选项
    loginAction: '下一步: 认证并且选择一个实例'
    authentication: 认证
    location: 位置
    planDetails:
      label: 实例详情
      memory: 内存
      drives: 驱动
    image:
      label: 镜像
    size:
      label: 大小
    regionSection: 区域
    region:
      label: 区域
  driverRackspace:
    accountSection: 账户访问
    username:
      label: 用户名
      placeholder: 你的RackSpace用户名
    apiKey:
      label: API 密钥
      placeholder: 你的RackSpace APK Key
    accountHelp: RackSpace控制面板中的账户配置
    regionSection: 区域
    region:
      label: 区域
    instanceSection: 实例
    instanceOptionsSection: 实例选项
    flavor:
      label: 偏好
  driverVsphere:
    accountSection: 账户访问
    vcenter:
      label: vCenter 主机
      placeholder: vCenter或者ESXi主机名/IP
    vcenterPort:
      label: vCenter端口
    username:
      label: 用户名
    password:
      label: 密码
    instanceSection: 实例
    instanceOptionsSection: 实例选项
    cpuCount:
      label: 处理器
    memorySize:
      label: 内存
      unit: MB
    diskSize:
      label: 磁盘
      unit: MB
    boot2dockerUrl:
      label: 操作系统ISO下载地址
      placeholder: 缺省:最新的boot2docker镜像
    schedulingSection: 计划
    dataCenter:
      label: 数据中心
    pool:
      label: 池
    host:
      label: 主机
      placeholder: "使用群集时输入\"/\""
    network:
      label: 网络
    dataStore:
      label: 数据存储
  driverAliyunecs:
    accountSection: 账户设置
    accessKey:
      label: 访问密钥*
      placeholder: 阿里云账号中的 Access Key
    accessKeySecret:
      label: 访问秘钥令牌*
      placeholder: 阿里云账号Access Key 对应的Secret
    apiEndpoint:
      label: API网关地址
      placeholder: 如果你是私有的阿里云服务器,请输入API地址
    instanceSection: 实例设置
    instanceOptionsSection: 实例选项部分
    instanceDescription:
      label: 实例描述
      placeholder: 实例描述
    instanceType:
      label: 实例类型
      placeholder: 实例类型
    systemImage:
      label: 系统镜像
      placeholder: 系统镜像
    instanceTag:
      label: 实例标签
      placeholder: 阿里云中实例显示的标签
    internetMaxBandwidth:
      label: 最大网络带宽
      placeholder: 1 到 100
    aliyunSLB:
      label: 阿里云负载均衡ID
      placeholder: 如果需要使用阿里云的负载均衡服务,请输入ID
    storageSection: 存储设置
    ioOptimized:
      label: 是否存储IO优化(none代表不优化，optimized代表优化)
      placeholder: 不优化或者优化
    systemDiskCategory:
      label: 系统盘种类
      placeholder: 选择了优化IO时,可输入cloud_efficiency, cloud_ssd or ephemeral_ssd.
    dataDiskCategory:
      label: 数据盘种类
      placeholder: 选择了优化IO时,可输入cloud_efficiency, cloud_ssd or ephemeral_ssd.
    dataDiskSize:
      label: 数据盘空间
      placeholder: 数据盘空间
    region:
      label: 实例所在地区
      placeholder: 实例所在地区
    zone:
      label: 可用区
      placeholder: 留空代表自动选择
    networkSection: 网络设置
    routeCIDR:
      label: 路由CIDR
      placeholder: '例如: 192.168.1.0/24'
    vpcId:
      label: 阿里云虚拟网络ID
      placeholder: 如果需要使用阿里云虚拟网络,请输入虚拟网络ID
    vswitchId:
      label: 阿里云虚拟交换机ID
      placeholder: 如果创建的时VPC类型实例,需要制定虚拟交换机ID
    privateIp:
      label: 内网IP
      placeholder: 实例私网IP地址
    privateAddressOnly:
      label: 是否只有私网IP
    securitySection: 安全设置
    securityGroup:
      label: 安全组
      placeholder: 安全组
    sshPassword:
      label: SSH 密码
      placeholder: 创建实例后SSH远程登录密码,留空则自动设置
modalAboutComponent:
  component: 组件
  version: 版本
  cattle: Cattle
  cli: 命令行
  ui: 用户界面
  compose: 编排
  machineService: 主机服务
modalAddPayment:
  header: 添加新的付款方式
  save: 保存
  errors:
    cc: 不正确的信用卡号码
    exp: 不正确的有效期
    cvc: 不正确的CVC number
    street: 街道信息为必填项
    city: 城市信息为必填项
    state: 省份信息为必填项
    zip: 邮编信息为必填项
  form:
    currency:
      label: 选择币种
    cc:
      label: 信用卡号码
      placeholder: '• • • • • • • • • • • •'
    default:
      label: 默认卡
    name:
      label: 所有者名称
      placeholder: '约翰 · 史密斯'
    exp:
      label: 有效期
      placeholder: '••/••'
    cvc:
      label: CVC号码
      placeholder: '• • •'
    address:
      addressLine1:
        label: 地址栏1
      addressLine2:
        label: 地址栏2
      city:
        label: 城市
        placeholder: Shanghai
      state:
        label: 省
        placeholder: Shanghai
      zip:
        label: 邮编
        placeholder: '99999'
      country:
        label: 国家
        placeholder: China
  currencies:
    yuan: "人民币 (¥)"
    euro: "欧元 (€)"
    dollar: "美元 ($)"
modalAuditlogInfo:
  header: 额外日志信息
  request: "请求对象:"
  response: "响应对象:"
modalContainerStop:
  header: "确认要停止"
  helpText: "在超时时间后容器将被强制停止"
  protip: '高级技巧: 在点击停止按钮时按住 {key} 键以跳过此确认提示'
  label: 超时
  button: 停止
modalContainerToService:
  title: '把 "{instanceName}" 转换成服务'
  detail: '这将基于此容器创建一个新的服务，并将这个容器作为服务的一部分。'
  action: 转换
modalConfirmDeactivate:
  header: 是否确认要
  protip: 高级技巧:在点击 {isServiceButton} 时按住 {key}  键以跳过确认操作
  cancel: 取消
  buttons:
    project:
      message: 停用你的环境
      button: 停用
    environment:
      message: 停止服务
      button: 停止服务
    default:
      message: 停用
      button: 停用
modalConfirmRemovePayment:
  header: '确认移除付款信息'
  title: '是否确认要删除'
  card: '以 {card} 结尾的信用卡'
modalEditDriver:
  url:
    label: 下载URL
  uiUrl:
    label: 自定义UI URL
    link: 参考 <a href="https://github.com/rancher/ui-driver-skel" target="_blank">ui-driver-skel</a> 以了解更多信息。
  checksum:
    label: 校验和
    help: '可选: 检验下载的驱动是否匹配期望的校验和'
modalEditSetting:
  title: 编辑高级设置
  name:
    label: 名称
  value:
    label: 值
    prompt: 选择一个值...
  reset:
    label: 重置为默认值
modalFeedback:
  header: 欢迎使用 {appName}!
  subtitle: "在开始使用前, 请让我们了解关于您的信息..."
  send: 开始使用
modalHostEvacuate:
  header: "确认进行疏散操作"
  helpText: "此操作将停用该主机并删除主机上所有运行的非基础设施容器。"
  protip: '进阶提示: 在点击时按住 {key}  键以跳过确认操作。'
  button: 疏散
modalProcessError:
  header: 异常信息
  cause: "原因:"
  stackTrace: "堆栈跟踪:"
  close: 关闭
modalRollbackService:
  title: '回滚 "{instanceName}"'
  titleWithSidekicks: '回滚 "{instanceName}" & {count, plural, =1 {# sidekick} other {# sidekicks}}'
  action: 回滚
  current:
    label: 当前版本
  revisionId:
    label: 回滚到版本
    prompt: 选择版本..
  difference:
    label: 区别
modalShell:
  title: 命令行:{instanceName}
modalShortcuts:
  world: 世界
  time: 时间
  title:
    rancher: "欢迎来到传送门！"
    pl: 快捷键
  navigation: 页面导航
  a: 应用
  b: 均衡器
  c: 容器
  d: DNS
  e: 管理集群与环境
  k: API 密钥
  other: 其他的东西
  g: 切换分组视图
  n: "添加新的[the current resource]"
  s: 切换系统视图
  t: 下一页 »
  v: 数据卷
  slash: 搜索框聚焦
  question: 你在这里
  admin: 只为管理员
  p: 进程
  theme: 循环主题({currentTheme})
modalWelcome:
  header: 欢迎使用 {appName}!
  closeModal: 确认
newBalancer:
  header:
    add: 添加负载均衡
    edit: 编辑负载均衡
    upgrade: 升级负载均衡
  error:
    noRules: "必须有一个或多个目标规则和监听端口"
    noSourcePort: "每条规则必须设置源端口"
    invalidSourcePort: '不正确的源端口: ''{num}'''
    invalidTargetPort: '不正确的目标端口: ''{num}'''
    mixedPort: "端口 {num} 有多条冲突的访问/协议规则"
    noTarget: "每条规则必须设置目标端口"
    noTargetPort: "每个规则需要设置目标端口"
    needsCertificate: "设置SSL/TLS规则时需要证书"
    stackName: "请输入新应用的名称"
newCatalog:
  version:
    prompt: 选择版本...
    default: 当前默认 (当前版本 {version})
  saveUpgrade: 升级
  saveNew: 启动
  saveConfigure: 设置
  upgrade: "升级:"
  catalog: "应用商店:"
  category: "类别:"
  support: "支持:"
  official: 官方认证
  maintainedBy: 由社区成员维护
  maintainer: "维护者:"
  license: "授权:"
  url: "项目URL:"
  titleAdd: "添加 {name} 应用"
  titleUpgrade: "升级 {name} 应用"
  titleConfigure: "设置 {name} 应用"
  templateVersion: 模板版本
  selectVersionAdd: 选择一个模板版本部署
  selectVersionUpgrade: 选择一个模板版本升级
  selectVersionConfigure: 选择一个模板版本设置
  config: 配置选项
  unknownType: "未识别问题类型:"
  startService: 创建后启动服务
  preview: 预览
  txt: answers.txt
  noConfig: 该模板没有配置选项
newContainer:
  add:
    sidekick: '添加从容器'
    sidekickName: '添加 "{name}" 的从容器'
  upgrade:
    container: 升级容器
    service: 升级服务
    globalService: 升级全局服务
    sidekick: 升级从容器
    sidekickName: '升级 "{name}" 的从容器'
  selectUpgrade: 选择一个或者多个服务进行升级
  saveUpgrade: 升级
  saveNew: 启动
  name:
    placeholder: 例如:myapp
  description:
    placeholder: 例如:我的应用
  environment:
    label: 环境变量
    addAction: 添加变量
    keyLabel: 变量
    keyPlaceholder: '例如: FOO'
    valueLabel: 值
    valuePlaceholder: '例如: bar'
  sidekick:
    header: 升级服务
    title: 选择加载配置的服务来升级
    detail: '"{service}" 有一些从容器加载了配置，你想要一起升级吗？'
    primary: 主容器
    sidekick: 从容器
  errors:
    noSidekick: 选择要添加从容器的服务
    duplicateName: '服务 "{service}" 中已存在名为 "{name}" 的从容器'
newPassword:
  placeholder: 新密码
  password: 新密码
  confirmPassword: 确认密码
  passwordNoMatch: 密码不匹配
newReceiver:
  title:
    edit: 编辑接收器
    add: 添加接收器
  name:
    placeholder: "例如: scale-web"
  driver:
    label: 类型
  action:
    label: 操作
    up: 扩容
    down: 缩容
  deleteOption:
    label: 缩容时删除
    mostRecent: 最近创建的主机
    leastRecent: 最旧的主机
  hostSelector:
    addActionLabel: 添加选择器标签
  image:
    label: Docker镜像名称
  service:
    label: 目标服务
  serviceSelector:
    label: 服务选择器
    addActionLabel: 添加选择器标签
    help: 符合标签的服务将被升级
  amount:
    label: 步长
  min:
    label: 最小数量
    placeholder: '例如: 1'
  max:
    label: 最大数量
    placeholder: '例如: 20'
  payloadFormat:
    label: 镜像仓库Webhook参数格式
    alicloud: 阿里云
  tag:
    label: 镜像标签
    placeholder: "例如: latest"
    help: 仅当镜像库中对应标签的镜像更新时才会触发服务更新.
orchestrationWelcome:
  simple:
    title: 简单
  enhanced:
    title: 通过Kubernetes加强
pageFooter:
  notARelease: (非正式发布)
  help: '帮助&文档'
  issues: 提交问题
  forums: 论坛
  slack: Slack
  download:
    link: 下载CLI
    mac: MacOS
    windows: Windows
    linux: Linux
  showSystem: 显示系统容器
pagination:
  certificate: |
    {pages, plural,
    =0 {无证书}
    =1 {{count} {count, plural, =1 {个证书} other {个证书}}}
    other {{count}个证书中的 {from} - {to}}}
  dnsRecord: |
    {pages, plural,
    =0 {无DNS记录}
    =1 {{count} {count, plural, =1 {个DNS记录} other {个DNS记录}}}
    other {{count}个DNS记录中的 {from} - {to}}}
  driverOptions: |
    {pages, plural,
    =0 {无驱动选项}
    =1 {{count} {count, plural, =1 {个驱动选项} other {个驱动选项}}}
    other {{count}个驱动选项中的 {from} - {to}}}
  entry: |
    {pages, plural,
    =0 {无条目}
    =1 {{count} {count, plural, =1 {个条目} other {个条目}}}
    other {{count}个条目中的 {from} - {to}}}
  event: |
    {pages, plural,
    =0 {无事件}
    =1 {{count} {count, plural, =1 {个事件} other {个事件}}}
    other {{count}个事件中的 {from} - {to}}}
  generic: |
    {pages, plural,
    =0 {无实例}
    =1 {{count} {count, plural, =1 {个实例} other {个实例}}}
    other {{count}个实例中的 {from} - {to}}}
  link: |
    {pages, plural,
    =0 {无链接}
    =1 {{count} {count, plural, =1 {个链接} other {个链接}}}
    other {{count}个链接中的 {from} - {to}}}
  loadBalancer: |
    {pages, plural,
    =0 {无负载均衡}
    =1 {{count} {count, plural, =1 {个负载均衡} other {个负载均衡}}}
    other {{count}个负载均衡中的 {from} - {to}}}
  port: |
    {pages, plural,
    =0 {无端口}
    =1 {{count} {count, plural, =1 {个端口} other {个端口}}}
    other {{count}个端口中的 {from} - {to}}}
  rule: |
    {pages, plural,
    =0 {无规则}
    =1 {{count} {count, plural, =1 {个规则} other {个规则}}}
    other {{count}个规则中的 {from} - {to}}}
  service: |
    {pages, plural,
    =0 {无服务}
    =1 {{count} {count, plural, =1 {个服务} other {个服务}}}
    other {{count}个服务中的 {from} - {to}}}
  volume: |
    {pages, plural,
    =0 {没有卷}
    =1 {{count} {count, plural, =1 {个卷} other {个卷}}}
    other {{count}个卷中的 {from} - {to}}}
projectRow:
  none: 无描述
  orchestration: 编排
publicEndpoints:
  endpoint: 终端
  bindIpAddress: 绑定IP
  publicPort: 映射端口
  privatePort: 容器端口
  noData: 无映射端口
  noMatch: 没有匹配当前搜索的端口
physicalStats:
  title: 物理属性
  detail: 物理计算机属性
registryRow:
  address: 地址
  username: 用户名
  created: 创建时间
reservationParameters:
  label: 资源限制
  memory:
    labelText: '内存'
    placeholder: '默认: 整个主机'
    unit: 'MB'
  milliCpu:
    labelText: 处理器
    placeholder: '默认: 整个主机'
saveCancel:
  saving: 保存中...
  saved: 已保存!
  edit: 保存
  create: 创建
  cancel: 取消
schema:
  inputBoolean:
    y: "是"
    n: "否"
  inputCertificate:
    prompt: 选择证书...
  inputContainer:
    prompt: 选择一个容器...
  inputEnum:
    option: 选择选项...
  inputHost:
    label: 选择主机...
  inputService:
    prompt: 选择服务...
    custom: 自定义
  inputSecret:
    prompt: 选择密文...
schedulingRuleRow:
  theHost: 主机
  must: 必须
  should: 最好
  shouldNot: 最好没有
  mustNot: 必须没有
  haveA: 具有
  of: 其
  hostLabel: 主机标签
  containerLabel: 容器标签
  serviceName: 服务名称
  containerName: 容器名称
serviceLink:
  withAlias:
    sameStack: "{service} 链接为 {alias}"
    differentStack: "{stack}/{service} 链接为 {alias}"
  noAlias:
    sameStack: "{service}"
    differentStack: "{stack}/{service}"
serviceLog:
  time: 时间
  level: 级别
  event: 事件
  detail: 详情
  noMatch: 没有符合当前搜索的事件
  noData: 最近没有发生任何事件
siteAccess:
  header: 站点访问
  helpText: "配置允许哪些人登录和使用 {appName}."
  unrestricted: "允许任何有效的 {individuals}"
  restricted: "允许环境成员, 以及授权的 {individuals} 和 {collection}"
  required: "仅允许授权的 {individuals} 和 {collection}"
  listHeader: "授权的 {individuals} 和 {collection}"
  noIdentity: 无
  users: 用户
  groups: 组
  organizations: 组织
svgServiceContainer:
  sidekicks: 从容器
tableCountSelect:
  header: 每页显示行数
telemetryOpt:
  header: 信息统计
  subtext: |
    Rancher Labs希望能够收集您环境的匿名配置信息以帮助改进{appName}产品。<br/> 您的信息不会被提供给任何第三方，收集的信息不包含特定的资源名称或地址。
  learnMore:
    label: 了解更多
  label: 允许收集匿名统计信息
tooltipLink:
  list: 列表
  composeYaml: 编排文件
tooltipWarning:
  notConfigured: 未设置访问控制
  dismiss: 取消
upgradeBtn:
  version:
    current: '当前版本'
  status:
    none: '无'
    loading: '检查更新...'
    current: '已经是最新版本'
    available: '有可用更新'
    inprogress: '升级进行中'
    upgraded: '已升级: 完成升级'
    notfound: '未识别模板版本'
    error: '检查更新出错'
    required: '需要升级'
viewEditDescription:
  form:
    name:
      placeholder: 例如:lab
    description:
      placeholder: 例如:开发实验环境
viewEditProject:
  showEdit:
    edit: "编辑环境"
    add: 添加环境
    template: 环境模板
    cluster:
      label: 集群
      prompt: 选择一个集群...
    accessControl: 访问控制
    noMembers: 添加一个或者多个成员能够使用此环境的成员
  networkPolicy:
    label: 网络策略
    description: 控制受管网络中哪些容器彼此之间能够进行通讯
    unsupported: 此环境中的网络策略设置暂不支持通过UI进行设置，请使用API管理网络策略。
    noManager: 网络策略功能仅在使用Cattle编排且部署了Network Policy Manager基础设施模板的环境中可用。
    withinStack: 应用内部
    withinService: 服务内部
    withinLinked: 链接服务之间
    default: 其他
    allow: 允许
    deny: 禁止
  header: "环境"
  description: 描述
  helpBlock: |
    未启用访问控制。<br/>
    任何访问API/UI的人都具有管理员权限，并能够使用任何环境。
volumesPage:
  title: 卷
  noMatch: 没有符合当前搜索的数据卷
  banner:
    driver: 驱动
    size: 大小
    stack: 应用
    perCont: 容器
    host: 主机
  scope:
    label: 作用域
    stack: 应用栈
    container: 每个容器
    standalone: 环境
  driver:
    label: 驱动
  driverOptions:
    title: 驱动选项
    detail: 驱动选项的键值对
    labels:
      key: 键
      value: 值
      noData: 没有选项
  mounts:
    label: 挂载
    detail: 该卷相关联的物理挂载
    table:
      instance: 实例
      path: 路径
      permission: 权限
      volume: 卷
      noData: 没有挂载
vmConsole:
  header: "控制台:"
  protip: 高级技巧:启动命令行时按下 {key} 键可在新窗口中打开.
  canvas: 暂不提供Canvas支持
  footerActions:
    buttonSend: 发送Ctrl-Alt-Delete
    buttonCancel: 关闭
volumeRow:
  mounts:
    readOnly: "(只读)"
waitOrchestration:
  count: '({sub} / {count})'
waitKubernetes:
  addHost: '添加至少一台主机'
  activateHost: '等待主机激活'
  createStack: '创建 Kubernetes 系统应用栈'
  startServices: '启动服务'
  waitApi: '等待 Kubernetes API'
containerChoices:
  hostGroup: 主机:{name}
  hostGroupWithState: 主机:{name}{state}
  unknownHost: 主机:???
  containerOption: "{name}"
nav:
  srToggleDropdown: 切换下拉菜单
  environment:
    cluster: 集群
    label: 环境
    all: 所有环境
    your: 你的环境
    selected: 当前环境
    edit: '编辑 "{name}"'
  containers:
    systemTab: 系统
    balancers: 均衡器
    dns: 域名解析服务器
    volumes: 数据卷
    k8s: 高级
    addContainer: 添加容器
    addBalancer: 添加负载均衡
    addDns: 添加DNS记录
    addVolume: 添加卷
    importCompose: 导入compose.yml
  catalog:
    all: 全部
    library: 官方认证
    community: 社区贡献
  infra:
    tab: 资源
    storagePage: 存储
    certificates: 证书
    registries: 镜像库
    secrets: 密文
    keys: API 密钥
    hooks: Webhooks
    templateKeys: 模板Keys
  user:
    label: 用户菜单:{username}
    logout: 注销
  userPreferences:
    link: "设定"
action:
  activate: 激活
  addSidekick: 添加从容器
  clone: 克隆
  console: 打开控制台
  convertToService: 转换为服务
  deactivate: 停用
  edit: 编辑
  editService: 编辑服务
  evacuate: 疏散
  execute: 执行命令行
  exportConfig: 导出配置
  garbageCollect: 清理
  logs: 查看日志
  pause: 暂停
  remove: 删除
  replay: 重播
  restart: 重启
  retry: 重试
  rollback: 回滚
  setDefault: 设置为缺省
  start: 启动
  stop: 停止
  upgrade: 升级
  upgradeOrEdit: 升级/编辑
  viewConfig: 查看配置
  viewGraph: 查看图形
  viewInApi: API查看
  viewInstance: 查看实例
validation:
  required: '"{key}" 必须设置'
  arrayLength:
    exactly: '"{key}" 应当包含 {count, plural, =1 {# item} other {# items}}'
    between: '"{key}" 应当介于 {min} 和 {max} 之间 {max, plural, =1 {item} other {items}}'
    min: '"{key}" 应当至少为 {count} {count, plural, =1 {item} other {items}}'
    max: '"{key}" 应当至多为 {count} {count, plural, =1 {item} other {items}}'
  stringLength:
    exactly: '"{key}" 应当为 {count, plural, =1 {# character} other {# characters}}'
    between: '"{key}" 应当介于 {min} 和 {max} 之间 {max, plural, =1 {character} other {characters}}'
    min: '"{key}" 应当至少为 {count} {count, plural, =1 {character} other {characters}}'
    max: '"{key}" 应当至多为 {count} {count, plural, =1 {character} other {characters}}'
  number:
    exactly: '"{key}" 应当为 {val}'
    between: '"{key}" 应当介于 {min} 和 {max} 之间'
    min: '"{key}" 应当至少为 {val}'
    max: '"{key}" 应当至多为 {val}'
  chars: '"{key}" 包含 {count, plural, =1 {an invalid character} other {# invalid characters}}: {chars}'
model:
  account:
    kind:
      registeredAgent: 已注册代理
      agent: 代理
      service: 服务
      user: 用户
      admin: 管理员
      project: 环境
  identity:
    displayType:
      user: 用户
      team: 团队
      group: 组
      org: 组织
      localUser: 本地用户
      unknown: "{type}？"
  projectMember:
    role:
      member: 成员
      owner: 所有者
      readonly: 只读
      restricted: 受限
  scaleService:
    min: 最小数量
    max: 最大数量
    amount: 以
